{"/home/travis/build/npmtest/node-npmtest-nexe/test.js":"/* istanbul instrument in package npmtest_nexe */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nexe/lib.npmtest_nexe.js":"/* istanbul instrument in package npmtest_nexe */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nexe = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nexe = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nexe/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nexe && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nexe */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nexe\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nexe.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nexe.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nexe.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nexe.__dirname + '/lib.npmtest_nexe.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nexe/node_modules/nexe/lib/index.js":"module.exports = require(\"./exe\");\n","/home/travis/build/npmtest/node-npmtest-nexe/node_modules/nexe/lib/exe.js":"/**\n * Copyright (c) 2013 Craig Condon\n * Copyright (c) 2015-2016 Jared Allard\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n **/\n\n'use strict';\n\nconst async = require(\"async\"),\n  mkdirp    = require(\"mkdirp\"),\n  request   = require(\"request\"),\n  gunzip    = require(\"gunzip-maybe\"),\n  path      = require(\"path\"),\n  fs        = require(\"fs\"),\n  tarstream = require('tar-stream'),\n  colors    = require('colors'),\n  ncp       = require(\"ncp\").ncp,\n  ProgressBar = require(\"progress\"),\n  child_process = require(\"child_process\"),\n  glob      = require(\"glob\"),\n  bundle    = require(\"./bundle\"),\n  embed     = require(\"./embed\"),\n  os        = require(\"os\"),\n  _log      = require(\"./log\"),\n  _monkeypatch = require(\"./monkeypatch\"),\n  spawn     = child_process.spawn;\n\nconst isWin = /^win/.test(process.platform);\n\nlet isPy,\n    framework,\n    version;\n\n/**\n * Compiliation process.\n */\n\nexports.compile = function(options, complete) {\n\n  var nodeCompiler, nexeEntryPath;\n\n  async.waterfall([\n    /**\n     *check relevant options\n     */\n    function checkOpts(next) {\n      /* failsafe */\n      if (options === undefined) {\n        _log(\"error\", \"no options given to .compile()\");\n        process.exit()\n      }\n\n      /**\n       * Have we been given a custom flag for python executable?\n       **/\n      if (options.python !== 'python' && options.python !== \"\" && options.python !== undefined) {\n        if (isWin) {\n          isPy = options.python.replace(/\\//gm, \"\\\\\"); // use windows file paths, batch is sensitive.\n        } else {\n          isPy = options.python;\n        }\n\n        _log(\"set python as \" + isPy);\n      } else {\n        isPy = \"python\";\n      }\n\n      // remove dots\n      options.framework = options.framework.replace(/\\./g, \"\");\n\n      // set outter-scope framework variable.\n      framework = options.framework;\n      _log(\"framework => \" + framework);\n\n      version = options.nodeVersion; // better framework vc\n\n      // check iojs version\n      if (framework === \"iojs\" && version === \"latest\") {\n        _log(\"fetching iojs versions\");\n        mkdirp(options.nodeTempDir); // make temp dir, probably repetive.\n\n        // create write stream so we have control over events\n        var output = fs.createWriteStream(path.join(options.nodeTempDir,\n          \"iojs-versions.json\"));\n\n        request.get(\"https://iojs.org/dist/index.json\")\n          .pipe(output);\n\n        output.on('close', function() {\n          _log(\"done\");\n          var f = fs.readFileSync(path.join(options.nodeTempDir,\n            \"iojs-versions.json\"));\n          f = JSON.parse(f);\n          version = f[0].version.replace(\"v\", \"\");\n\n          _log(\"iojs latest => \" + version);\n\n          // continue down along the async road\n          next();\n        });\n      } else {\n        next();\n      }\n    },\n\n    /**\n     * first download node\n     */\n    function downloadNode(next) {\n      _downloadNode(version, options.nodeTempDir, options.nodeConfigureArgs, options.nodeMakeArgs, next);\n    },\n\n    /**\n     * Embed Resources into a base64 encoded array.\n     **/\n    function embedResources(nc, next) {\n      nodeCompiler = nc;\n\n      _log(\"embedResources %s\", options.resourceFiles);\n      embed(options.resourceFiles, options.resourceRoot, nc, next);\n    },\n\n    /**\n     * Write nexeres.js\n     **/\n    function writeResources(resources, next) {\n      let resourcePath = path.join(nodeCompiler.dir, \"lib\", \"nexeres.js\");\n      _log(\"resource -> %s\", resourcePath);\n\n      fs.writeFile(resourcePath, resources, next);\n    },\n\n    /**\n     * Bundle the application into one script\n     **/\n    function combineProject(next) {\n      _log(\"bundle %s\", options.input);\n      bundle(options.input, nodeCompiler.dir, options, next);\n    },\n\n    /**\n     * monkeypatch some files so that the nexe.js file is loaded when the app runs\n     */\n\n    function monkeyPatchNodeConfig(next) {\n      _monkeyPatchNodeConfig(nodeCompiler, next);\n    },\n\n    /**\n     * monkeypatch node.cc to prevent v8 and node from processing CLI flags\n     */\n    function monkeyPatchNodeCc(next) {\n      if (options.flags) {\n        _monkeyPatchMainCc(nodeCompiler, next);\n      } else {\n        next();\n      }\n    },\n\n    function monkeyPatchv8FlagsCc(next) {\n      if (options.jsFlags) {\n        return _monkeyPatchv8FlagsCc(nodeCompiler, options, next);\n      }\n\n      return next();\n    },\n\n    /**\n     * monkeypatch child_process.js so nexejs knows when it is a forked process\n     */\n    function monkeyPatchChildProc(next) {\n      _monkeyPatchChildProcess(nodeCompiler, next);\n    },\n\n    /**\n     * If an old compiled executable exists in the Release directory, delete it.\n     * This lets us see if the build failed by checking the existence of this file later.\n     */\n\n    function cleanUpOldExecutable(next) {\n      fs.unlink(nodeCompiler.releasePath, function(err) {\n        if (err) {\n          if (err.code === \"ENOENT\") {\n            next();\n          } else {\n            throw err;\n          }\n        } else {\n          next();\n        }\n      });\n    },\n\n    /**\n     * compile the node application\n     */\n\n    function makeExecutable(next) {\n      if (isWin) {\n        _log(\"vcbuild [make stage]\");\n      } else {\n        _log(\"make\");\n      }\n      nodeCompiler.make(next);\n    },\n\n    /**\n     * we create the output directory if needed\n     */\n\n    function makeOutputDirectory(next) {\n      mkdirp(path.dirname(options.output), function() {\n        next();\n      });\n    },\n\n    /**\n     * Verify that the executable was compiled successfully\n     */\n\n    function checkThatExecutableExists(next) {\n      fs.exists(nodeCompiler.releasePath, function(exists) {\n        if (!exists) {\n          _log(\"error\",\n            \"The release executable has not been generated. \" +\n            \"This indicates a failure in the build process. \" +\n            \"There is likely additional information above.\"\n          );\n          process.exit(1);\n        } else {\n          next();\n        }\n      });\n    },\n\n    /**\n     * Copy the compilied binary to the output specified.\n     */\n\n    function copyBinaryToOutput(next) {\n      _log(\"cp %s %s\", nodeCompiler.releasePath, options.output);\n      ncp(nodeCompiler.releasePath, options.output, function(err) {\n        if (err) {\n          _log(\"error\", \"Couldn't copy binary.\");\n          throw err; // dump raw error object\n        }\n        _log('copied');\n\n        next();\n      });\n    }\n  ], complete);\n}\n\n/**\n * Download a version of node\n *\n * @param {string} version, version of node to download\n * @param {string} directory, where to store the downloaded src\n * @param {function} complete, callback\n */\n\nfunction _downloadNode(version, directory, nodeConfigureArgs, nodeMakeArgs, complete) {\n  var nodeFileDir = path.resolve(path.join(directory, framework, version)), // fixes #107, was process.cwd(), + rest.\n    nodeFilePath = path.resolve(path.join(nodeFileDir, framework + \"-\" + version + \".tar.gz\"));\n\n\n  // might already be downloaded, and unzipped\n  if (_getNodeCompiler(nodeFileDir, nodeConfigureArgs, nodeMakeArgs, complete)) {\n    return;\n  }\n\n\n  async.waterfall([\n\n    /**\n     * first make the directory where the zip file will live\n     */\n\n    function makeDirectory(next) {\n      mkdirp.sync(path.dirname(nodeFilePath));\n      next();\n    },\n\n    /**\n     * download node into the target directory\n     */\n\n    function downloadNode(next) {\n      if (fs.existsSync(nodeFilePath)) return next();\n\n      var uri = framework;\n\n      if (framework === \"node\") {\n        uri = 'nodejs'; // if node, use nodejs uri\n      } else if (framework === 'nodejs') {\n        framework = 'node'; // support nodejs, and node, as framework.\n      }\n\n      var type = global.type;\n      var url, prefix = \"https://\" + uri + \".org/dist\";\n\n      if (version === \"latest\") {\n        url = prefix + \"/\" + framework + \"-\" + version + \".tar.gz\";\n      } else {\n        url = prefix + \"/v\" + version + \"/\" + framework + \"-v\" + version + \".tar.gz\";\n      }\n\n      _log(\"downloading %s\", url);\n\n      var output = fs.createWriteStream(nodeFilePath, {\n        \"flags\": \"w+\"\n      });\n\n      // need to set user-agent to bypass some corporate firewalls\n      var requestOptions = {\n        url: url,\n        headers: {\n          \"User-Agent\": \"Node.js\"\n        }\n      }\n\n      _logProgress(request(requestOptions)).pipe(output);\n\n      output.on(\"close\", function() {\n        next();\n      });\n    },\n\n    /**\n     * unzip in the same directory\n     */\n\n    function unzipNodeTarball(next) {\n      var onError = function(err) {\n        console.log(err.stack);\n        _log(\"error\", \"failed to extract the node source\");\n        process.exit(1);\n      }\n\n      if (isWin) {\n        _log(\"extracting the node source [node-tar.gz]\");\n\n        // tar-stream method w/ gunzip-maybe\n        var read = fs.createReadStream(nodeFilePath);\n        var extract = tarstream.extract()\n        var basedir = nodeFileDir;\n\n        if (!fs.existsSync(nodeFileDir)) {\n          fs.mkdirSync(nodeFileDir);\n        }\n\n        extract.on('entry', function(header, stream, callback) {\n          // header is the tar header\n          // stream is the content body (might be an empty stream)\n          // call next when you are done with this entry\n\n          var absolutepath = path.join(basedir, header.name);\n          if (header.type === 'directory') {\n            // handle directories.\n            // console.log('dir:', header.name);\n            fs.mkdirSync(absolutepath);\n            return callback();\n          } else if (header.type === 'file') {\n            // handle files\n            // console.log('file:', header.name);\n          } else {\n            console.log(header.type + ':', header.name);\n            _log('warn', 'unhandled type in tar extraction, skipping');\n            return callback();\n          }\n\n          var write = fs.createWriteStream(absolutepath);\n\n          stream.pipe(write);\n\n          write.on('close', function() {\n            return callback();\n          });\n\n          stream.on('error', function(err) {\n            return onError(err);\n          })\n\n          write.on('error', function(err) {\n            return onError(err);\n          });\n\n          stream.resume() // just auto drain the stream\n        })\n\n        extract.on('finish', function() {\n          _log('extraction finished');\n          return next();\n        })\n\n        read.pipe(gunzip()).pipe(extract);\n      } else {\n        _log(\"extracting the node source [native tar]\");\n\n        var cmd = [\"tar\", \"-xf\", nodeFilePath, \"-C\", nodeFileDir];\n        _log(cmd.join(\" \"));\n\n        var tar = spawn(cmd.shift(), cmd);\n        tar.stdout.pipe(process.stdout);\n        tar.stderr.pipe(process.stderr);\n\n        tar.on(\"close\", function() {\n          return next();\n        });\n        tar.on(\"error\", onError);\n      }\n    },\n\n    /**\n     * return the compiler object for the node version\n     */\n\n    function(next, type) {\n      _getNodeCompiler(nodeFileDir, nodeConfigureArgs, nodeMakeArgs, next, type)\n    },\n\n  ], complete);\n}\n\n/**\n * Get the compilier we will use for whatever platform we may be on and configure\n * it.\n */\n\nfunction _getNodeCompiler(nodeFileDir, nodeConfigureArgs, nodeMakeArgs, complete, type) {\n  var dir = _getFirstDirectory(nodeFileDir);\n\n  // standard\n  var executable = \"node.exe\";\n  var binary = \"node\";\n\n  // iojs specifics.\n  if (framework === \"iojs\") {\n    executable = \"iojs.exe\";\n    binary = \"iojs\";\n  }\n\n  if (dir) {\n    if (isWin) {\n      complete(null, {\n        dir: dir,\n        version: path.basename(nodeFileDir),\n        releasePath: path.join(dir, \"Release\", executable),\n        make: function(next) {\n          // create a new env with minimal impact on old one\n          var newEnv = process.env\n\n          if (isPy !== \"python\") {\n            // add the dir of the suposed python exe to path\n            newEnv.path = process.env.PATH + \";\" + path.dirname(isPy)\n          }\n\n          // spawn a vcbuild process with our custom enviroment.\n          var vcbuild = spawn(\"vcbuild.bat\", [\"nosign\", \"release\"], {\n            cwd: dir,\n            env: newEnv\n          });\n          vcbuild.stdout.pipe(process.stdout);\n          vcbuild.stderr.pipe(process.stderr);\n          vcbuild.on(\"close\", function() {\n            next();\n          });\n        }\n      });\n    } else {\n      complete(null, {\n        dir: dir,\n        version: path.basename(nodeFileDir),\n        releasePath: path.join(dir, \"out\", \"Release\", binary),\n        make: function(next) {\n          var cfg = \"./configure\",\n            configure;\n\n          var conf = [cfg];\n\n          if (isPy !== \"python\") {\n            conf = [conf].concat(nodeConfigureArgs);\n          }\n\n          // should work for all use cases now.\n          configure = spawn(isPy, conf, {\n            cwd: dir.toString('ascii')\n          });\n\n          // local function, move to top eventually\n          function _loop(dir) {\n            /* eventually try every python file */\n            var pdir = fs.readdirSync(dir);\n\n            pdir.forEach(function(v, i) {\n              var stat = fs.statSync(dir + \"/\" + v);\n              if (stat.isFile()) {\n                // only process Makefiles and .mk targets.\n                if (v !== \"Makefile\" && path.extname(v) !== \".mk\") {\n                  return;\n                }\n\n                _log(\"patching \" + v);\n\n                /* patch the file */\n                var py = fs.readFileSync(dir + \"/\" + v, {\n                  encoding: 'utf8'\n                });\n                py = py.replace(/([a-z]|\\/)*python(\\w|)/gm, isPy); // this is definently needed\n                fs.writeFileSync(dir + \"/\" + v, py, {\n                  encoding: 'utf8'\n                }); // write to file\n\n                pv = undefined;\n              } else if (stat.isDirectory()) {\n                // must be dir?\n                // skip tests because we don't need them here\n                if (v !== \"test\") {\n                  _loop(dir + \"/\" + v)\n                }\n              }\n            });\n          }\n\n          configure.stdout.pipe(process.stdout);\n          configure.stderr.pipe(process.stderr);\n\n          // on error\n          configure.on(\"error\", function(err) {\n            console.log('Error:', err);\n            console.log('');\n            console.log('Details:');\n            console.log('command =', isPy, cfg, conf_args || '');\n            console.log('cwd =', dir);\n\n            var configure_path = path.join(dir, 'configure');\n            var contains_configure = fs.existsSync(configure_path);\n\n            console.log('cwd contains configure,', (contains_configure ? colors.green('yes') : colors.red('no')));\n\n            var configure_size = fs.statSync(configure_path).size;\n\n            console.log('configure is non-zero size,', ((configure_size > 0) ? colors.green('yes') : colors.red('no')));\n\n            _log(\"error\", \"failed to launch configure.\");\n            process.exit(1);\n          });\n\n          // when it's finished\n          configure.on(\"close\", function() {\n            if (isPy !== \"python\") {\n              /**\n               * Originally I thought this only applied to io.js,\n               * however I soon found out this affects node.js,\n               * so it is now mainstream.\n               */\n              _log(\"preparing python\");\n\n              // loop over depends\n              _loop(dir);\n            }\n\n            if (nodeMakeArgs === undefined) {\n              nodeMakeArgs = [];\n            }\n\n            var platformMake = \"make\";\n            if (os.platform().match(/bsd$/) != null) {\n              platformMake = \"gmake\";\n            }\n\n            var make = spawn(platformMake, nodeMakeArgs, {\n              cwd: dir\n            });\n            make.stdout.pipe(process.stdout);\n            make.stderr.pipe(process.stderr);\n            make.on(\"error\", function(err) {\n              console.log(err);\n              _log(\"error\", \"failed to run make.\");\n              process.exit(1);\n            })\n            make.on(\"close\", function() {\n              next();\n            });\n          })\n        }\n      });\n    }\n    return true;\n  }\n\n  return false;\n}\n\n/**\n */\n\nfunction _monkeyPatchNodeConfig(compiler, complete) {\n  async.waterfall([\n    /**\n     * monkeypatch the gyp file to include the nexe.js and nexeres.js files\n     */\n    function(next) {\n      _monkeyPatchGyp(compiler, next)\n    },\n\n    /**\n     * monkeypatch main entry point\n     */\n    function(next) {\n      _monkeyPatchMainJs(compiler, next)\n    }\n  ], complete);\n}\n\n/**\n * patch the gyp file to allow our custom includes\n */\n\nfunction _monkeyPatchGyp(compiler, complete) {\n\n  var gypPath = path.join(compiler.dir, \"node.gyp\");\n\n  _monkeypatch(\n    gypPath,\n    function(content) {\n      return ~content.indexOf(\"nexe.js\");\n    },\n    function(content, next) {\n      next(null, content.replace(\"'lib/fs.js',\", \"'lib/fs.js', 'lib/nexe.js', 'lib/nexeres.js', \"))\n    },\n    complete\n  )\n}\n\n/**\n */\n\nfunction _monkeyPatchMainJs(compiler, complete) {\n  var mainPath = path.join(compiler.dir, \"src\", \"node.js\");\n\n  if(!fs.existsSync(mainPath)) {\n    _log('warn', 'src/node.js doesn\\'t exist. Trying \\'lib/internal/bootstrap_node.js\\'')\n    mainPath = path.join(compiler.dir, \"lib/internal\", \"bootstrap_node.js\");\n  }\n\n  _monkeypatch(\n    mainPath,\n    function(content) {\n      return ~content.indexOf(\"nexe\");\n    },\n    function(content, next) {\n      next(null, content.replace(/\\(function\\(process\\) \\{/, '\\\n(function(process) {\\n\\\n  process._eval = \\'require(\"nexe\");\\';\\n\\\n  if (process.argv[1] !== \"nexe.js\") {\\n\\\n    process.argv.splice(1, 0, \"nexe.js\");\\n\\\n  }\\n\\\n'))\n    },\n    complete\n  );\n}\n\n/**\n * Make child_process work.\n */\nfunction _monkeyPatchChildProcess(compiler, complete) {\n  var childProcPath = path.join(compiler.dir, \"lib\", \"child_process.js\");\n\n  _monkeypatch(\n    childProcPath,\n    function(content) {\n      return ~content.indexOf(\"--child_process\");\n    },\n    function(content, next) {\n      next(null, content.replace(/return spawn\\(/, 'args.unshift(\"nexe.js\", \"--child_process\");\\n  return spawn('));\n    },\n    complete\n  );\n}\n\n/**\n * Patch node.cc to not check the internal arguments.\n */\n\nfunction _monkeyPatchMainCc(compiler, complete) {\n  let finalContents;\n\n  let mainPath = path.join(compiler.dir, \"src\", \"node.cc\");\n  let mainC = fs.readFileSync(mainPath, {\n    encoding: 'utf8'\n  });\n\n  // content split, and original start/end\n  let constant_loc = 1;\n  let lines = mainC.split('\\n');\n  let startLine = lines.indexOf('  // TODO use parse opts');\n  let endLine = lines.indexOf('  option_end_index = i;'); // pre node 0.11.6 compat\n  let isPatched = lines.indexOf('// NEXE_PATCH_IGNOREFLAGS');\n\n  if (isPatched !== -1) {\n    _log('already patched node.cc');\n    return complete();\n  }\n\n  /**\n   * This is the new method of passing the args. Tested on node.js 0.12.5\n   * and iojs 2.3.1\n   **/\n  if (endLine === -1 && startLine === -1) { // only if the pre-0.12.5 failed.\n    _log(\"using the after 0.12.5 method of ignoring flags.\");\n\n    startLine = lines.indexOf(\"  while (index < nargs && argv[index][0] == '-') {\"); // beginning of the function\n    endLine = lines.indexOf('  // Copy remaining arguments.');\n    endLine--; // space, then it's at the }\n\n    constant_loc = lines.length + 1;\n  } else {\n    _log('using 0.10.x > method of ignoring flags');\n    lines[endLine] = '  option_end_index = 1;';\n  }\n\n  /**\n   * This is the method for 5.5.0\n   **/\n  if (endLine === -1 || startLine === -1) {\n    _log(\"using the after 5.5.0 method of ignoring flags.\");\n\n    startLine = lines.indexOf(\"  while (index < nargs && argv[index][0] == '-' && !short_circuit) {\"); // beginning of the function\n    endLine = lines.indexOf('  // Copy remaining arguments.');\n    endLine--; // space, then it's at the }\n\n    constant_loc = lines.length + 1;\n  }\n\n  // other versions here.\n  if (endLine === -1 || startLine === -1) { // failsafe.\n    _log(\"error\", \"Failed to find a way to patch node.cc to ignoreFlags\");\n    _log(\"startLine =\", startLine, '| endLine =', endLine);\n    process.exit(1);\n  }\n\n  // check if it's been done\n  lines[constant_loc] = '// NEXE_PATCH_IGNOREFLAGS';\n\n  for (var i = startLine; i < endLine; i++) {\n    lines[i] = undefined; // set the value to undefined so it's skipped by the join\n  }\n\n  _log('patched node.cc');\n\n  finalContents = lines.join('\\n');\n\n  // write the file contents\n  fs.writeFile(mainPath, finalContents, {\n    encoding: 'utf8'\n  }, function(err) {\n    if (err) {\n      _log('error', 'failed to write to', mainPath);\n      return process.exit(1);\n    }\n\n    return complete();\n  });\n}\n\n/**\n * Patch flags.cc from deps/v8/src to use hard-coded flags.\n * this function is very closely ready to accept custom injection code.\n **/\nfunction _monkeyPatchv8FlagsCc(compiler, options, complete) {\n  var mainPath = path.join(compiler.dir, \"deps/v8/src\", \"flags.cc\");\n\n  fs.readFile(mainPath, {\n    encoding: 'utf8'\n  }, function(err, contents) {\n    if (err) {\n      return _log('error', 'failed to read', mainPath);\n    }\n\n    // Super simple injection here. Perhaps make it an array at somepoint?\n    var injection = '\\\nconst char* nexevargs = \"{{args}}\";\\n\\\nint nexevargslen = strlen(nexevargs);\\n\\\nSetFlagsFromString(nexevargs, nexevargslen);\\n\\\n';\n\n    var injectionSplit = injection.split('\\n');\n    var injectionLength = injectionSplit.length;\n    var contentsSplit = contents.split('\\n');\n    var contentsLength = contentsSplit.length;\n    var lastInjectionLine = injectionSplit[injectionLength - 2];\n\n    var lineToInjectAfter = contentsSplit.indexOf('  ComputeFlagListHash();');\n    var haveWeInjectedBefore = contentsSplit.indexOf(lastInjectionLine);\n\n    var lineInjectDifference = contentsLength - lineToInjectAfter;\n\n    // support for 0.12.x\n    if (lineToInjectAfter === -1) {\n      _log('warn', 'Using an expiramental support patch for 0.12.x');\n      lineToInjectAfter = contentsSplit.indexOf('#undef FLAG_MODE_DEFINE_IMPLICATIONS');\n    }\n\n    // support for 0.10.x\n    if (lineToInjectAfter === -1) {\n      _log('warn', '0.12.x patch failed. Trying 0.10.0 patch');\n      lineToInjectAfter = contentsSplit.indexOf('#define FLAG_MODE_DEFINE_IMPLICATIONS') + 1;\n    }\n\n    // this is debug, comment out.\n    // _log('v8 injection is', injectionLength, 'newlines long');\n    // _log('v8 flags source is', contentsLength, 'newlines long');\n\n    // console.log(finalContents)\n\n    var finalContents,\n      dontCombine;\n\n    if (lineToInjectAfter !== -1 && haveWeInjectedBefore === -1) {\n      _log('injecting v8/flags.cc');\n\n      // super debug\n      // _log('v8 injection determined by', lastInjectionLine);\n      // _log('v8 inject after line', lineToInjectAfter);\n      // _log('v8 inject needs to shift', lineInjectDifference, 'amount of lines by', injectionLength);\n\n      // compute out the amount of space we'll need in this.\n      var startShiftLine = contentsLength - 1; // minus one to make up for 0 arg line.\n      var endShiftLine = lineToInjectAfter;\n      var injectRoom = injectionLength - 1;\n\n      injectionSplit[0] = injectionSplit[0].replace('{{args}}', options.jsFlags);\n\n      for (var i = startShiftLine; i !== endShiftLine; i--) {\n        contentsSplit[i + injectRoom] = contentsSplit[i];\n        contentsSplit[i] = '';\n      }\n\n      var injectionPos = 0;\n      for (var i = 0; i !== injectionLength - 1; i++) {\n        contentsSplit[(lineToInjectAfter + 1) + injectionPos] = injectionSplit[injectionPos];\n        injectionPos++;\n      }\n    } else if (lineToInjectAfter !== -1 && haveWeInjectedBefore !== -1) {\n      _log('re-injecting v8 args');\n\n      dontCombine = true;\n      finalContents = contentsSplit.join('\\n');\n      finalContents = finalContents.replace(/const char\\* nexevargs = \"[A-Z\\-\\_]*\";/gi,\n        'const char* nexevargs = \"' + options.jsFlags + '\";');\n    } else {\n      _log('error', 'failed to find a suitable injection point for v8 args.',\n        'File a bug report with the node version and log.');\n\n      _log('lineToInjectAfter=' + lineToInjectAfter, 'haveWeInjectedBefore=' + haveWeInjectedBefore);\n      return process.exit(1);\n    }\n\n    if (!dontCombine) {\n      finalContents = contentsSplit.join('\\n');\n    }\n\n    // write the file contents\n    fs.writeFile(mainPath, finalContents, {\n      encoding: 'utf8'\n    }, function(err) {\n      if (err) {\n        _log('error', 'failed to write to', mainPath);\n        return process.exit(1);\n      }\n\n      return complete();\n    })\n  });\n}\n\n/**\n * Get the first directory of a string.\n */\n\nfunction _getFirstDirectory(dir) {\n  var files = glob.sync(dir + \"/*\");\n\n  for (var i = files.length; i--;) {\n    var file = files[i];\n    if (fs.statSync(file).isDirectory()) return file;\n  }\n\n  return false;\n}\n\n/**\n * Log the progress of a request object.\n */\n\nfunction _logProgress(req) {\n\n  req.on(\"response\", function(resp) {\n\n    var len = parseInt(resp.headers[\"content-length\"], 10),\n      bar = new ProgressBar(\"[:bar]\", {\n        complete: \"=\",\n        incomplete: \" \",\n        total: len,\n        width: 100 // just use 100\n      });\n\n    req.on(\"data\", function(chunk) {\n      bar.tick(chunk.length);\n    });\n  });\n\n  req.on(\"error\", function(err) {\n    console.log(err);\n    _log(\"error\", \"failed to download node sources,\");\n    process.exit(1);\n  });\n\n  return req;\n}\n\n/**\n * Attempt to parse the package.json for nexe information.\n *\n * @param {string} path - path to package.json\n * @param {object} options - fallback options\n *\n * @todo implement options overriding package defaults.\n * @todo make this much less hackily implemented....\n *\n * @return {object} nexe.compile - options object\n **/\nexports.package = function(path, options) {\n  let _package; // scope\n\n  // check if the file exists\n  if (fs.existsSync(path) === false) {\n    _log(\"warn\", \"no package.json found.\");\n  } else {\n    _package = require(path);\n  }\n\n  if(!_package || !_package.nexe) {\n    _log('error', 'trying to use package.json variables, but not setup to do so!');\n    process.exit(1);\n  }\n\n  // replace ^$ w/ os specific extension on output\n  if (isWin) {\n    _package.nexe.output = _package.nexe.output.replace(/\\^\\$/, '.exe') // exe\n  } else {\n    _package.nexe.output = _package.nexe.output.replace(/\\^\\$/, '') // none\n  }\n\n  // construct the object\n  let obj = {\n    input: (_package.nexe.input || options.i),\n    output: (_package.nexe.output || options.o),\n    flags: (_package.nexe.runtime.ignoreFlags || (options.f || false)),\n    nodeMakeArgs: (_package.nexe.runtime.nodeMakeArgs || []),\n    resourceFiles: (_package.nexe.resourceFiles),\n    nodeVersion: (_package.nexe.runtime.version || options.r),\n    nodeConfigureArgs: (_package.nexe.runtime.nodeConfigureArgs || []),\n    nodeMakeArgs: (_package.nexe.runtime.nodeMakeArgs || []),\n    jsFlags: (_package.nexe.runtime['js-flags'] || options.j),\n    python: (_package.nexe.python || options.p),\n    debug: (_package.nexe.debug || options.d),\n    nodeTempDir: (_package.nexe.temp || options.t),\n    framework: (_package.nexe.runtime.framework || options.f)\n  }\n\n  // browserify options\n  if(_package.nexe.browserify !== undefined) {\n    obj.browserifyRequires = (_package.nexe.browserify.requires || []);\n    obj.browserifyExcludes = (_package.nexe.browserify.excludes || []);\n    obj.browserifyPaths    = (_package.nexe.browserify.paths    || []);\n  }\n\n  // TODO: get rid of this crappy code I wrote and make it less painful to read.\n  Object.keys(_package.nexe).forEach(function(v, i) {\n    if (v !== \"runtime\" && v !== 'browserify') {\n      _log(\"log\", v + \" => '\" + _package.nexe[v] + \"'\");\n    }\n  });\n\n  return obj;\n}\n","/home/travis/build/npmtest/node-npmtest-nexe/node_modules/nexe/bin/nexe":"#!/usr/bin/env node\n\nvar path = require('path'),\n  fs = require('fs'),\n  nexe = require('../lib'),\n  _log = require(\"../lib/log\"),\n  cli = require('yargs').\nusage('Usage: $0 -i [sources] -o [binary]').\noptions('i', {\n  demand: true,\n  alias: 'input',\n  desc: 'The entry javascript files',\n  default: process.cwd()\n}).\noptions('o', {\n  demand: true,\n  alias: 'output',\n  desc: 'The output binary',\n  default: \"out.nex\"\n}).\noptions('r', {\n  alias: 'runtime',\n  default: 'latest',\n  description: 'The node.js runtime to use'\n}).\noptions('t', {\n  alias: 'temp',\n  default: './tmp/nexe',\n  description: 'The path to store node.js sources'\n}).\noptions('f', {\n  alias: 'flags',\n  description: 'Don\\'t parse node and v8 flags, pass through app flags',\n  default: false\n}).\noptions('d', {\n  alias: 'debug',\n  default: false,\n  description: 'generate and use source maps, large file size'\n}).\noptions('j', {\n  alias: 'jsFlags',\n  default: false,\n  description: 'v8 flags for runtime'\n}).\noptions('v', {\n  alias: 'version',\n  description: 'Display version number'\n}).\noptions('p', {\n  alias: 'python',\n  description: 'Set path of python to use.',\n  default: 'python'\n}).\noptions('F', {\n  alias: 'framework',\n  description: 'Set the framework to use',\n  default: 'nodejs'\n});\n\nvar argv = cli.argv;\nif (argv.h || argv.help) {\n  cli.showHelp();\n  process.exit();\n} else if (argv.v || argv.version) {\n  var pkginfo = require('../package.json');\n  console.log(pkginfo.version);\n  process.exit();\n}\n\n/**\n * TODO: Support network shares?\n **/\nfunction toAbsolute(pt) {\n  if (pt.substr(0, 1) == \"/\") return pt; // for *nix \"/\"\n  if (pt.substr(0, 2) == \"\\\\\\\\\") return pt; // for windows \"\\\\\"\n  if (pt.substr(1, 3) == \":/\") return pt; // for windows \"c:/\"\n\n  // otheerwise...\n  return path.join(process.cwd(), pt);\n}\n\nif (fs.lstatSync(argv.i).isDirectory()) {\n  opts = nexe.package(path.join(argv.i, \"package.json\"), argv);\n  nexe.compile(opts, function(error) {\n    if (error) {\n      return console.log(error.message);\n    }\n  });\n} else {\n  /**\n   * Call the core\n   **/\n  nexe.compile({\n      input: require.resolve(toAbsolute(argv.i)),\n      output: toAbsolute(argv.o),\n      flags: argv.f,\n      nodeVersion: argv.r,\n      python: argv.python,\n      nodeTempDir: toAbsolute(argv.t),\n      framework: argv.F\n    },\n    function(error) {\n      if (error) {\n        return console.log(error.message);\n      }\n    }\n  );\n}\n","/home/travis/build/npmtest/node-npmtest-nexe/node_modules/nexe/lib/bundle.js":"/**\n * Copyright (c) 2013 Craig Condon\n * Copyright (c) 2015-2016 Jared Allard\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n **/\n\n'use strict';\n\nlet browserify    = require('browserify'),\n    path          = require(\"path\"),\n    spawn         = require('child_process').spawn,\n    insertGlobals = require('insert-module-globals'),\n    fs            = require(\"fs\"),\n    async         = require(\"async\"),\n    _log          = require(\"./log\");\n\n/**\n * User browserify to create a \"packed\" file.\n *\n * @param {string} input - input file\n * @param {string} nc - node compiler dir\n * @param {array} options - nexe options\n * @param {function} complete - next function to call (async)\n **/\nfunction bundle(input, nc, options, complete) {\n  const bundlePath = path.join(nc, \"lib\", \"nexe.js\");\n  const mapfile    = options.output+'.map';\n  let ws           = fs.createWriteStream(bundlePath);\n\n\n  const igv = '__filename,__dirname,_process';\n  let insertGlobalVars = {},\n      wantedGlobalVars = igv.split(',');\n\n  // parse insertGlobalVars.\n  Object.keys(insertGlobals.vars).forEach(function (x) {\n    if (wantedGlobalVars.indexOf(x) === -1) {\n      insertGlobalVars[x] = undefined;\n    }\n  });\n\n  let paths = [path.join(nc, 'lib')];\n\n  if(options.browserifyPaths) {\n    paths = paths.concat(options.browserifyPaths);\n  }\n\n\n  _log('executing browserify via API');\n  let bproc = browserify([input], {\n    debug: options.debug,\n    commondir: false,\n    paths: paths,\n    builtins: false,\n    insertGlobalVars: insertGlobalVars,\n    detectGlobals: true,\n    browserField: false\n  });\n\n  if (options.browserifyExcludes && Array.isArray(options.browserifyExcludes)) {\n    for (let i = 0; i < options.browserifyExcludes.length; i++) {\n      let lib = options.browserifyExcludes[i];\n      _log('Excluding \\'%s\\' from browserify bundle', lib);\n      bproc.exclude(lib);\n    }\n  }\n\n  // copy the excludes code for requires for now.\n  if (options.browserifyRequires && Array.isArray(options.browserifyRequires)) {\n    for (let i = 0; i < options.browserifyRequires.length; i++) {\n      let lib = options.browserifyRequires[i];\n      let name = lib.file || lib; // for  object format.\n\n      _log('Force including \\'%s\\' in browserify bundle', name);\n      bproc.require(lib);\n    }\n  }\n\n  if(options.debug) {\n    bproc.require(require.resolve('source-map-support'))\n  }\n\n  let bprocbun = bproc.bundle() // bundle\n      .pipe(ws) // pipe to file\n\n  // error on require errors, still can't contionue. ffs browserify\n  bprocbun.on('error', function(err) {\n    _log('error', '[browserify] '+err);\n  });\n\n  ws.on('error', function(err) {\n    console.log(err);\n    _log('error', 'Failed to save stdout to disk');\n    process.exit(1);\n  })\n\n  ws.on('close', function() {\n    var source = fs.readFileSync(bundlePath, 'utf8');\n    source = source.replace(/[^\\x00-\\x7F]/g, \"\");\n\n    // write the source modified to nexe.js\n    fs.writeFile(bundlePath, source, 'utf8', function(err) {\n      if (err) {\n        _log('error', 'failed to save source');\n        process.exit(1);\n      }\n\n      complete();\n    });\n  });\n}\n\nmodule.exports = bundle;\n","/home/travis/build/npmtest/node-npmtest-nexe/node_modules/nexe/lib/log.js":"/**\n * Copyright (c) 2013 Craig Condon\n * Copyright (c) 2015-2016 Jared Allard\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n **/\n\nvar colors = require('colors');\n\n/**\n * standard output, takes 3 different types.\n * log, error, and warn\n *\n * @param {any} arguments - Text to output.\n * @return undefined\n **/\nfunction _log () {\n\n  var args = Array.prototype.slice.call(arguments, 0),\n  level = args.shift();\n\n  if (!~[\"log\", \"error\", \"warn\"].indexOf(level)) {\n    args.unshift(level);\n    level = \"log\";\n  }\n\n  if(level == \"log\") {\n    args[0] = \"----> \" + args[0];\n  } else if(level == \"error\") {\n    args[0] = \"....> \" + colors.red(\"ERROR: \") + args[0]\n  } else if(level == \"warn\") {\n    args[0] = \"....> \" + colors.yellow(\"WARNING: \") + args[0]\n  }\n\n  console[level].apply(console, args);\n}\n\n// export the log function, for require()\nmodule.exports = _log;\n","/home/travis/build/npmtest/node-npmtest-nexe/node_modules/nexe/lib/embed.js":"/**\n * Copyright (c) 2013 Craig Condon\n * Copyright (c) 2015-2016 Jared Allard\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n **/\n\n'use strict';\n\nlet path = require(\"path\"),\n  fs = require(\"fs\");\n\n/**\n * Accessort for embed\n **/\nconst accessor = function(key) {\n  if (embeddedFiles.hasOwnProperty(key)) {\n    return new Buffer(embeddedFiles[key], 'base64');\n  } else {\n    //file was not embedded, throw err.\n    throw new Error('Embedded file not found');\n  }\n}\n\n/**\n * Embed files.\n *\n * @param {array} resourceFiles - array of files to embed.\n * @param {string} resourceRoot - root of resources.\n * @param {function} compelte   - callback\n **/\nfunction embed(resourceFiles, resourceRoot, options, complete) {\n  const encode = function(filePath) {\n    return fs.readFileSync(filePath).toString('base64');\n  }\n\n  resourceFiles = resourceFiles || [];\n  resourceRoot = resourceRoot || \"\";\n\n  if (!Array.isArray(resourceFiles)) {\n    throw new Error(\"Bad Argument: resourceFiles is not an array\");\n  }\n\n  let buffer = \"var embeddedFiles = {\\n\";\n  for (let i = 0; i < resourceFiles.length; ++i) {\n    buffer += JSON.stringify(path.relative(resourceRoot, resourceFiles[i])) + ': \"';\n    buffer += encode(resourceFiles[i]) + '\",\\n';\n  }\n\n  buffer += \"\\n};\\n\\nmodule.exports.keys = function () { return Object.keys(embeddedFiles); }\\n\\nmodule.exports.get = \";\n  buffer += accessor.toString();\n  complete(null, buffer);\n}\n\nmodule.exports = embed;\n","/home/travis/build/npmtest/node-npmtest-nexe/node_modules/nexe/lib/monkeypatch.js":"/**\n * Copyright (c) 2013 Craig Condon\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n **/\n \nvar async = require(\"async\"),\n    fs    = require(\"fs\"),\n   _log   = require(\"./log\");\n\n/**\n * Monkey patch a file.\n *\n * @param {string} filePath - path to file.\n * @param {function} monkeyPatched - function to process contents\n * @param {function} processor - TODO: detail what this is\n * @param {function} complete - callback\n *\n * @return undefined\n */\nfunction _monkeypatch (filePath, monkeyPatched, processor, complete) {\n\n  async.waterfall([\n\n    function read (next) {\n      fs.readFile(filePath, \"utf8\", next);\n    },\n\n    // TODO - need to parse gyp file - this is a bit hacker\n    function monkeypatch (content, next) {\n\n      if (monkeyPatched(content)) return complete();\n\n      _log(\"monkey patch %s\", filePath);\n      processor(content, next);\n    },\n\n    function write (content, next) {\n      fs.writeFile(filePath, content, \"utf8\", next);\n    }\n  ], complete);\n}\n\n// export the function for require()\nmodule.exports = _monkeypatch;\n"}